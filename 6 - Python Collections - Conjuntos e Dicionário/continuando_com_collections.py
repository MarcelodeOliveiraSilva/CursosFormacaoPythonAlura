# -*- coding: utf-8 -*-
"""Continuando com Collections.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FP1R5tHsyMfrEm8uTBoipUZ57O2MLe4r
"""

usuarios_data_science = [15,23,43,56]
usuarios_machine_learning = [13,23,56,42]

assistiram = usuarios_data_science.copy()
assistiram.extend(usuarios_machine_learning)
assistiram

len(assistiram)

set(assistiram)

set([1,2,3,1,1])

{1,2,3,1}

usuarios_data_science = {15,23,43,56}
usuarios_machine_learning = {13,23,56,42}

usuarios_machine_learning

usuarios_machine_learning[3]

for usuario in set(assistiram):
  print(usuario)

usuarios_data_science = {15,23,43,56}
usuarios_machine_learning = {13,23,56,42}

#todo mundo q fez os cursos
usuarios_data_science | usuarios_machine_learning

#só quem fez os dois cursos
usuarios_data_science & usuarios_machine_learning

# quem está no primeiro mas n está no segundo
usuarios_data_science - usuarios_machine_learning

fez_ds_mas_nao_fez_mal = usuarios_data_science - usuarios_machine_learning
15 in fez_ds_mas_nao_fez_mal

23 in fez_ds_mas_nao_fez_mal

#fez um ou o outro, mas não os dois
usuarios_data_science ^ usuarios_machine_learning

usuarios = {1,5,76,34,52,13,17}
len(usuarios)

#conjuntos são mutaveis, ou seja, é psosivel add, mas n em posição pois conjuntos n tem posição
usuarios.add(13)
len(usuarios)

usuarios.add(765)
len(usuarios)

usuarios

#para tornar o conjunto imutavel, congela o congunto
usuarios = frozenset(usuarios)
usuarios

type(usuarios)

meu_texto = "bem vindo meu nome é marcelo eu gosto muito de nomes e tenho o meu cachorro e gosto muito de cachorro"
#split quebra o texto a cada espaço em bco
#set fez um conjunto de cada palavra q foi colocada após o split quebrar o texto
set(meu_texto.split())

#Dicionario (mapa)
#saber qts vzs apareceu cada palavra
aparicoes = {
    "guilherme": 1,
    "cachorro": 2,
    "nome": 2,
    "vindo":1
}

type(aparicoes)

aparicoes["guilherme"]

aparicoes["cachorro"]

aparicoes.get("xpto", 0)

aparicoes.get("cachorro", 0)

aparicoes = dict(guilherme = 2, cachorro = 1)
aparicoes

aparicoes = {
    "guilherme": 1,
    "cachorro": 2,
    "nome": 2,
    "vindo":1
}

#acrescentar elemento
aparicoes["carlos"] = 1

aparicoes

aparicoes["carlos"] = 2

aparicoes

#remover elemento
del aparicoes["carlos"]

aparicoes

#verificar valores dentro das chaves
"cachorro" in aparicoes

#imprimir todos elementos
for elemento in aparicoes:
    print(elemento)

#imprimir todos elementos da esquerda
for elemento in aparicoes.keys():
    print(elemento)

#imprimir todos elementos da direita das chaves(valores)
for elemento in aparicoes.values():
    print(elemento)

#imprimir linha por linha
#imprimir todos elementos
for elemento in aparicoes.keys():
    valor = aparicoes[elemento]
    print(elemento,valor)

#imprimir linha por linha
#imprimir todos elementos
for elemento in aparicoes.items():
    print(elemento)

for chave, valor in aparicoes.items():
  print(chave, "=" , valor)

["palavra {}".format(chave) for chave in aparicoes.keys()]

meu_texto = "Bem vindo meu nome é Marcelo eu gosto muito de nomes e tenho o meu cachorro e gosto muito de cachorro"
meu_texto = meu_texto.lower()

aparicoes = {}

for palavra in meu_texto.split():
    ate_agora = aparicoes.get(palavra, 0)
    aparicoes[palavra] = ate_agora + 1 

aparicoes

from collections import defaultdict

aparicoes = defaultdict(int)

for palavra in meu_texto.split():
    ate_agora = aparicoes[palavra]
    aparicoes[palavra] = ate_agora + 1 

aparicoes

dicionario = defaultdict(int)
dicionario['guilherme']

dicionario['guilherme'] = 15
dicionario['guilherme']

aparicoes = defaultdict(int)

for palavra in meu_texto.split():
    aparicoes[palavra] += 1 

aparicoes

class Conta:
  def __init__(self):
    print("imprimindo classe conta")

contas = defaultdict(Conta)
contas[15]

contas[17]

from collections import Counter

aparicoes = Counter()

for palavra in meu_texto.split():
    ate_agora = aparicoes[palavra]
    aparicoes[palavra] = ate_agora + 1 

aparicoes

aparicoes = Counter(meu_texto.split())

aparicoes

#TESTANDO O USO DE DIVERSAS COLEÇOES CONTANDO LETRAS

texto1 = """
Progressive Web Apps são incríveis. Você pode tirar proveito de toda estrutura Web para criar apps com HTML, JavaScript e CSS sem tanta preocupação se você vai rodar uma aplicação no iOS, Android ou mesmo no navegador.

Quer ver o que você pode fazer com PWA e com tudo que vou te trazer nesse artigo? Olha só esse video onde mostro as possibilidades de uma app consumindo uma API da Nasa:
O Vue, que é um framework muito conhecido no front-end, pode ser utilizado para a criação de uma app mobile usando PWA. Para facilitar esse trabalho, existe o Quasar Framework.

O Quasar pega um único código front-end, que usa Vue.js, e consegue exportá-lo para uma série de tecnologias diferentes: desde Single Page Applications e PWAs até aplicações desktop com Electron.

Então, se você já tem uma app web usando o Vue, fica relativamente simples colocá-la nas lojas usando o Quasar.

Eu escrevi um artigo com detalhes para você criar uma PWA com Quasar no blog da Kovi, onde trabalho atualmente. Lá você pode encontrar como construir do zero o PWA e gerar seus arquivos para a publicação.

Na Kovi a gente usa Quasar para a nossa app. Mais: dentro de uma webview em Flutter! Isso mostra as possibilidades infinitas que temos de mesclar essas tecnologias para facilitar o desenvolvimento multiplataforma e até aproveitar as habilidades de front-enders dos times.

"""

texto2 = """
Imagine a seguinte situação: uma empresa faz altos investimentos no desenvolvimento de um produto só para descobrir no final que o público-alvo era, na verdade, bem diferente daquele que a equipe tinha planejado e, por isso, tinha necessidades diferentes. Ninguém quer passar por isso, principalmente os(as) investidores(as), uma vez que uma situação semelhante é um desperdício de tempo e recursos.
Essa frustração é evitada quando pesquisas e testes bem planejados fazem parte do projeto, pois eles trazem resultados que ajudam a equipe a montar estratégias e moldar a melhor experiência que o usuário pode ter. O conhecimento, em conjunto com a estratégia, resulta em produtos consistentes, mais assertivos e com maior probabilidade de agradar os usuários.

Se algo abrange produto e usuário, saiba que a UX Design está envolvida! Dentro da área da UX, existe uma especialização própria para coordenar pesquisas e testes com o usuário: a UX Research!

UX Research, ou Pesquisa de Experiência do Usuário, é uma área da UX Design especializada em entender o usuário e suas dores através de pesquisas, entrevistas, testes e análise de dados. Os profissionais de UX Research são responsáveis pelo planejamento, aplicação da pesquisa ou teste e o tratamento dos resultados de forma que possam gerar insights válidos para o projeto. Sem as pesquisas e os testes, a probabilidade de um serviço ou produto dar errado é muito grande e, consequentemente, gerar uma grande carga de retrabalho para a equipe.
"""

#calculando a frequencia de aparecimento de cada letra no texto 1

def analisa_frequencia_de_letras(texto):
  aparicoes = Counter(texto.lower())
  total_de_caracteres = sum(aparicoes.values())

  proporcoes = [(letra, frequencia / total_de_caracteres) for letra,frequencia in aparicoes.items()]
  proporcoes = Counter(dict(proporcoes))
  mais_comuns = proporcoes.most_common(10)

  for caractere, proporcao in mais_comuns:
    print(" {} => {:.2f}%".format(caractere, proporcao*100))

analisa_frequencia_de_letras(texto1)

analisa_frequencia_de_letras(texto2)